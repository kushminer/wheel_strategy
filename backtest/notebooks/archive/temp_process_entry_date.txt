def process_entry_date(entry_date, ticker, positions_df, config):
    """
    Process a single entry date for a single ticker with realistic simulation.
    
    Features:
    - Liquidity filters
    - Slippage on entry
    - Transaction costs
    - Fixed cost basis calculation
    - Intermediate step caching for faster debugging
    
    Returns: (new_positions_df, exits_df, filtered_out_df)
    """
    print(f"\n{'='*60}")
    print(f"Processing {ticker} on {entry_date}")
    print('='*60)
    
    r = config['risk_free_rate']
    use_trading_days_filter = config.get('use_trading_days_for_dte_filter', True)
    use_trading_days_exit = config.get('use_trading_days_for_exit', True)
    exit_dte = config.get('exit_dte', 21)
    
    # ===========================================================================
    # STEP 1: Fetch options chain (uses API-level cache)
    # ===========================================================================
    df_opts = fetch_options_snapshot(ticker, entry_date)
    
    # ===========================================================================
    # STEP 2: Parse symbols
    # ===========================================================================
    df_parsed = load_step_cache('parsed_options', ticker, entry_date)
    if df_parsed is None:
        df_parsed = parse_option_symbols(df_opts)
        save_step_cache(df_parsed, 'parsed_options', ticker, entry_date)
    
    # ===========================================================================
    # STEP 3: Add DTE
    # ===========================================================================
    df_with_dte = load_step_cache('chain_with_dte', ticker, entry_date)
    if df_with_dte is None:
        df_with_dte = add_trading_dte(df_parsed, use_trading_days=use_trading_days_filter)
        save_step_cache(df_with_dte, 'chain_with_dte', ticker, entry_date)
    
    # ===========================================================================
    # STEP 4: Fetch underlying price (uses API-level cache)
    # ===========================================================================
    underlying_price = fetch_equity_price(ticker, entry_date)
    
    # ===========================================================================
    # STEP 5-7: Process chain snapshot with greeks
    # ===========================================================================
    chain_with_greeks = load_step_cache('chain_with_greeks', ticker, entry_date)
    if chain_with_greeks is None:
        # Keep only rows with quotes
        quotes = df_with_dte[df_with_dte["bid_px_00"].notna() & df_with_dte["ask_px_00"].notna()].copy()
        quotes["mid"] = (quotes["bid_px_00"] + quotes["ask_px_00"]) / 2
        
        # Collapse to one row per contract (latest quote)
        chain_snapshot = (
            quotes
            .sort_values("ts_event")
            .groupby(["symbol", "expiration", "strike", "call_put"])
            .tail(1)
            .copy()
        )
        chain_snapshot["underlying_last"] = underlying_price
        
        # Calculate IV and delta
        chain_snapshot["iv"] = chain_snapshot.apply(lambda row: compute_iv(row, r), axis=1)
        chain_snapshot["delta"] = chain_snapshot.apply(lambda row: compute_delta(row, r), axis=1)
        
        # Calculate exit dates
        chain_snapshot['date_exit'] = calculate_exit_dte_dates(
            chain_snapshot['expiration'], 
            exit_dte,
            use_trading_days=use_trading_days_exit
        )
        
        # Add entry date
        chain_snapshot['date'] = chain_snapshot['ts_event'].dt.date
        
        chain_with_greeks = chain_snapshot
        save_step_cache(chain_with_greeks, 'chain_with_greeks', ticker, entry_date)
    
    # ===========================================================================
    # STEP 8: Basic option filters (DTE, delta, type)
    # ===========================================================================
    candidates = load_step_cache('candidates', ticker, entry_date)
    if candidates is None:
        candidates = chain_with_greeks[
            (chain_with_greeks["call_put"] == config['option_type'])
            & chain_with_greeks["dte"].between(config['min_dte'], config['max_dte'])
            & chain_with_greeks["delta"].abs().between(config['min_delta'], config['max_delta'])
        ].copy()
        save_step_cache(candidates, 'candidates', ticker, entry_date)
    
    print(f"\nFound {len(candidates)} candidates passing basic filters (DTE, delta)")
    
    if len(candidates) == 0:
        return pd.DataFrame(), pd.DataFrame(), pd.DataFrame()
    
    # ===========================================================================
    # STEP 9: Apply liquidity filters (NOT cached - depends on config)
    # ===========================================================================
    filtered_out = []
    liquidity_passed = []
    
    for idx, row in candidates.iterrows():
        passes, reason = passes_liquidity_filter(row, config)
        if passes:
            liquidity_passed.append(idx)
        else:
            filtered_out.append({
                'symbol': row['symbol'],
                'strike': row['strike'],
                'dte': row['dte'],
                'reason': reason,
                'bid': row.get('bid_px_00', 0),
                'ask': row.get('ask_px_00', 0),
                'bid_size': row.get('bid_sz_00', 0),
                'ask_size': row.get('ask_sz_00', 0),
            })
    
    candidates = candidates.loc[liquidity_passed]
    filtered_out_df = pd.DataFrame(filtered_out)
    
    if config['liquidity']['enabled']:
        print(f"After liquidity filter: {len(candidates)} candidates")
        if len(filtered_out_df) > 0:
            print(f"  Filtered out: {len(filtered_out_df)} (reasons: {filtered_out_df['reason'].value_counts().to_dict()})")
    
    if len(candidates) == 0:
        return pd.DataFrame(), pd.DataFrame(), filtered_out_df
    
    # ===========================================================================
    # STEP 10: Filter out same-day duplicates (NOT cached - depends on positions_df)
    # ===========================================================================
    if len(positions_df) > 0:
        same_date_positions = positions_df[
            (positions_df['entry_date'] == entry_date) & 
            (positions_df['ticker'] == ticker)
        ]
        if len(same_date_positions) > 0:
            held_symbols = same_date_positions['symbol'].tolist()
            candidates = candidates[~candidates['symbol'].isin(held_symbols)]
            print(f"After removing same-day duplicates: {len(candidates)} candidates")
    
    if len(candidates) == 0:
        return pd.DataFrame(), pd.DataFrame(), filtered_out_df
    
    # ===========================================================================
    # STEP 11: Create backtest candidates with slippage and costs
    # ===========================================================================
    backtest_candidates = candidates.copy()
    
    # Apply entry slippage (selling puts)
    backtest_candidates['entry_premium'] = backtest_candidates.apply(
        lambda row: apply_entry_slippage(
            row['mid'], 
            row['bid_px_00'], 
            row['ask_px_00'], 
            config
        ), 
        axis=1
    )
    
    # Calculate cost basis (FIXED)
    backtest_candidates['cost_basis'] = backtest_candidates['strike'].apply(
        lambda s: calculate_cost_basis(s, config)
    )
    
    # Calculate entry costs
    backtest_candidates['entry_costs'] = calculate_entry_costs(1, config)
    
    # Calculate profit target based on slippage-adjusted premium
    backtest_candidates['exit_50_perc'] = config['profit_target_pct'] * backtest_candidates['entry_premium']
    
    # Track slippage
    backtest_candidates['entry_slippage'] = backtest_candidates['mid'] - backtest_candidates['entry_premium']
    
    # Select columns for output
    backtest_cols = [
        'symbol', 'date_exit', 'cost_basis', 'mid', 'entry_premium', 'entry_costs',
        'exit_50_perc', 'entry_slippage', 'date', 'dte', 'expiration', 'strike',
        'bid_px_00', 'ask_px_00', 'bid_sz_00', 'ask_sz_00', 'underlying_last'
    ]
    backtest_candidates = backtest_candidates[backtest_cols]
    
    print(f"\nBacktest candidates:")
    display_cols = ['symbol', 'strike', 'dte', 'mid', 'entry_premium', 'entry_slippage']
    print(backtest_candidates[display_cols].to_string())
    
    # ===========================================================================
    # STEP 12: Run exit strategy
    # ===========================================================================
    exits_df = backtest_exit_strategy(backtest_candidates, ticker, client, config)
    
    # ===========================================================================
    # STEP 13: Create new positions for tracking
    # ===========================================================================
    new_positions = backtest_candidates.copy()
    new_positions['entry_date'] = entry_date
    new_positions['ticker'] = ticker
    
    return new_positions, exits_df, filtered_out_df


print("Process entry date function defined (v2 with intermediate step caching)")

